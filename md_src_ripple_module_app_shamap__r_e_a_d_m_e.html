<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>RippleD: SHAMap Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RippleD
   </div>
   <div id="projectbrief">Ed&#39;s Take On RippleD</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">SHAMap Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>July 2014</p>
<p>The SHAMap is a Merkle tree (<a href="http://en.wikipedia.org/wiki/Merkle_tree">http://en.wikipedia.org/wiki/Merkle_tree</a>). The SHAMap is also a radix tree of radix 16 (<a href="http://en.wikipedia.org/wiki/Radix_tree">http://en.wikipedia.org/wiki/Radix_tree</a>).</p>
<p><em>We need some kind of sensible summary of the SHAMap here.</em></p>
<p>A given SHAMap always stores only one of three kinds of data:</p>
<ul>
<li>Transactions with metadata</li>
<li>Transactions without metadata, or</li>
<li>Account states.</li>
</ul>
<p>So all of the leaf nodes of a particular SHAMap will always have a uniform type. The inner nodes carry no data other than the hash of the nodes beneath them.</p>
<h2>SHAMap Types</h2>
<p>There are two different ways of building and using a SHAMap:</p>
<ol type="1">
<li>A mutable SHAMap and</li>
<li>An immutable SHAMap</li>
</ol>
<p>The distinction here is not of the classic C++ immutable-means-unchanging sense. An immutable SHAMap contains <em>nodes</em> that are immutable. Also, once a node has been located in an immutable SHAMap, that node is guaranteed to persist in that SHAMap for the lifetime of the SHAMap.</p>
<p>So, somewhat counter-intuitively, an immutable SHAMap may grow as new nodes are introduced. But an immutable SHAMap will never get smaller (until it entirely evaporates when it is destroyed). Nodes, once introduced to the immutable SHAMap, also never change their location in memory. So nodes in an immutable SHAMap can be handled using raw pointers (if you're careful).</p>
<p>One consequence of this design is that an immutable SHAMap can never be "trimmed". There is no way to identify unnecessary nodes in an immutable SHAMap that could be removed. Once a node has been brought into the in-memory SHAMap, that node stays in memory for the life of the SHAMap.</p>
<p>Most SHAMaps are immutable, in the sense that they don't modify or remove their contained nodes.</p>
<p>An example where a mutable SHAMap is required is when we want to apply transactions to the last closed ledger. To do so we'd make a mutable snapshot of the state tree and then start applying transactions to it. Because the snapshot is mutable, changes to nodes in the snapshot will not affect nodes in other SHAMAps.</p>
<p>An example using a immutable ledger would be when there's an open ledger and some piece of code wishes to query the state of the ledger. In this case we don't wish to change the state of the SHAMap, so we'd use an immutable snapshot.</p>
<h2>SHAMap Creation</h2>
<p>A SHAMap is usually not created from vacuum. Once an initial SHAMap is constructed, later SHAMaps are usually created by calling snapShot(bool isMutable) on the original SHAMap(). The returned SHAMap has the expected characteristics (mutable or immutable) based on the passed in flag.</p>
<p>It is cheaper to make an immutable snapshot of a SHAMap than to make a mutable snapshot. If the SHAMap snapshot is mutable then any of the nodes that might be modified must be copied before they are placed in the mutable map.</p>
<h2>SHAMap Thread Safety</h2>
<p>SHAMaps can be thread safe, depending on how they are used. The SHAMap uses a SyncUnorderedMap for its storage. The SyncUnorderedMap has three thread-safe methods:</p>
<ul>
<li>size(),</li>
<li>canonicalize(), and</li>
<li>retrieve()</li>
</ul>
<p>As long as the SHAMap uses only those three interfaces to its storage (the mTNByID variable [which stands for Tree Node by ID]) the SHAMap is thread safe.</p>
<h2>Walking a SHAMap</h2>
<p><em>We need a good description of why someone would walk a SHAMap and</em> <em>how it works in the code</em></p>
<h2>Late-arriving Nodes</h2>
<p>As we noted earlier, SHAMaps (even immutable ones) may grow. If a SHAMap is searching for a node and runs into an empty spot in the tree, then the SHAMap looks to see if the node exists but has not yet been made part of the map. This operation is performed in the <code>SHAMap::fetchNodeExternalNT()</code> method. The <em>NT</em> is this case stands for 'No Throw'.</p>
<p>The <code>fetchNodeExternalNT()</code> method goes through three phases:</p>
<ol type="1">
<li><p class="startli">By calling <code>getCache()</code> we attempt to locate the missing node in the TreeNodeCache. The TreeNodeCache is a cache of immutable SHAMapTreeNodes that are shared across all SHAMaps.</p>
<p class="startli">Any SHAMapTreeNode that is immutable has a sequence number of zero. When a mutable SHAMap is created then its SHAMapTreeNodes are given non-zero sequence numbers. So the <code>assert (ret-&gt;getSeq() == 0)</code> simply confirms that the TreeNodeCache indeed gave us an immutable node.</p>
</li>
<li>If the node is not in the TreeNodeCache, we attempt to locate the node in the historic data stored by the data base. The call to to <code>getApp().getNodeStore().fetch(hash)</code> does that work for us.</li>
<li><p class="startli">Finally, if mLedgerSeq is non-zero and we did't locate the node in the historic data, then we call a MissingNodeHandler.</p>
<p class="startli">The non-zero mLedgerSeq indicates that the SHAMap is a complete map that belongs to a historic ledger with the given (non-zero) sequence number. So, if all expected data is always present, the MissingNodeHandler should never be executed.</p>
<p class="startli">And, since we now know that this SHAMap does not fully represent the data from that ledger, we set the SHAMap's sequence number to zero.</p>
</li>
</ol>
<p>If phase 1 returned a node, then we already know that the node is immutable. However, if either phase 2 executes successfully, then we need to turn the returned node into an immutable node. That's handled by the call to <code>make_shared&lt;SHAMapTreeNode&gt;</code> inside the try block. That code is inside a try block because the <code>fetchNodeExternalNT</code> method promises not to throw. In case the constructor called by <code>make_shared</code> throws we don't want to break our promise.</p>
<h2>Canonicalize</h2>
<p>The calls to <code>canonicalize()</code> make sure that if the resulting node is already in the SHAMap, then we return the node that's already present &ndash; we never replace a pre-existing node. By using <code>canonicalize()</code> we manage a thread race condition where two different threads might both recognize the lack of a SHAMapTreeNode at the same time. If they both attempt to insert the node then <code>canonicalize</code> makes sure that the first node in wins and the slower thread receives back a pointer to the node inserted by the faster thread.</p>
<p>There's a problem with the current SHAMap design that <code>canonicalize()</code> accommodates. Two different trees can have the exact same node (the same hash value) with two different IDs. If the TreeNodeCache returns a node with the same hash but a different ID, then we assume that the ID of the passed-in node is 'better' than the older ID in the TreeNodeCache. So we construct a new SHAMapTreeNode by copying the one we found in the TreeNodeCache, but we give the new node the new ID. Then we replace the SHAMapTreeNode in the TreeNodeCache with this newly constructed node.</p>
<p>The TreeNodeCache is not subject to the rule that any node must be resident forever. So it's okay to replace the old node with the new node.</p>
<p>The <code>SHAMap::getCache()</code> method exhibits the same behavior.</p>
<h2>SHAMap Improvements</h2>
<p>Here's a simple one: the SHAMapTreeNode::mAccessSeq member is currently not used and could be removed.</p>
<p>Here's a more important change. The tree structure is currently embedded in the SHAMapTreeNodes themselves. It doesn't have to be that way, and that should be fixed.</p>
<p>When we navigate the tree (say, like <code>SHAMap::walkTo()</code>) we currently ask each node for information that we could determine locally. We know the depth because we know how many nodes we have traversed. We know the ID that we need because that's how we're steering. So we don't need to store the ID in the node. The next refactor should remove all calls to <code>SHAMapTreeNode::GetID()</code>.</p>
<p>Then we can remove the NodeID member from SHAMapTreeNode.</p>
<p>Then we can change the SHAMap::mTNBtID member to be mTNByHash.</p>
<p>An additional possible refactor would be to have a base type, SHAMapTreeNode, and derive from that InnerNode and LeafNode types. That would remove some storage (the array of 16 hashes) from the LeafNodes. That refactor would also have the effect of simplifying methods like <code>isLeaf()</code> and <code>hasItem()</code>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
